# FlowLang Bytecode Virtual Machine Specification

## Overview

The FlowLang Bytecode Virtual Machine (FBVM) is a stack-based virtual machine designed to execute FlowLang bytecode independently of the Rust runtime. This enables distribution of FlowLang programs as standalone executables.

## Architecture

### Stack-Based Design
- **Operand Stack**: Primary computation stack
- **Call Stack**: Function call frames
- **Heap**: Dynamic memory allocation
- **Constant Pool**: Immutable values and strings

### Memory Layout
```
┌─────────────────┐
│   Constant Pool │  ← Strings, numbers, function metadata
├─────────────────┤
│   Call Stack    │  ← Function frames
├─────────────────┤
│   Operand Stack │  ← Computation stack
├─────────────────┤
│      Heap       │  ← Objects, arrays, closures
└─────────────────┘
```

## Instruction Set

### Stack Operations
```
LOAD_CONST <index>     # Push constant from pool
LOAD_LOCAL <index>     # Push local variable
STORE_LOCAL <index>    # Pop and store to local
LOAD_GLOBAL <name>     # Push global variable
STORE_GLOBAL <name>    # Pop and store to global
DUP                    # Duplicate top of stack
POP                    # Remove top of stack
SWAP                   # Swap top two values
```

### Arithmetic Operations
```
ADD                    # Pop b, a; push a + b
SUB                    # Pop b, a; push a - b
MUL                    # Pop b, a; push a * b
DIV                    # Pop b, a; push a / b
MOD                    # Pop b, a; push a % b
NEG                    # Pop a; push -a
```

### Comparison Operations
```
EQ                     # Pop b, a; push a == b
NE                     # Pop b, a; push a != b
LT                     # Pop b, a; push a < b
LE                     # Pop b, a; push a <= b
GT                     # Pop b, a; push a > b
GE                     # Pop b, a; push a >= b
```

### Logical Operations
```
AND                    # Pop b, a; push a && b
OR                     # Pop b, a; push a || b
NOT                    # Pop a; push !a
```

### Control Flow
```
JUMP <offset>          # Unconditional jump
JUMP_IF_FALSE <offset> # Jump if top of stack is false
JUMP_IF_TRUE <offset>  # Jump if top of stack is true
CALL <argc>            # Call function with argc arguments
RETURN                 # Return from function
RETURN_VALUE           # Return with value from stack
```

### Object Operations
```
NEW_ARRAY <size>       # Create array with size elements
NEW_OBJECT             # Create empty object
GET_INDEX              # Pop index, array; push array[index]
SET_INDEX              # Pop value, index, array; array[index] = value
GET_PROPERTY <name>    # Pop object; push object.name
SET_PROPERTY <name>    # Pop value, object; object.name = value
```

### Function Operations
```
NEW_FUNCTION <index>   # Create function from constant pool
NEW_CLOSURE <index>    # Create closure capturing locals
CALL_METHOD <name>     # Call method on object
```

## Bytecode Format

### File Header
```
Magic Number: 0x464C4F57 ("FLOW")
Version: 1.0
Constant Pool Size: uint32
Code Size: uint32
Entry Point: uint32
```

### Constant Pool Entry Types
```
TYPE_INTEGER   = 0x01
TYPE_FLOAT     = 0x02
TYPE_STRING    = 0x03
TYPE_BOOLEAN   = 0x04
TYPE_NULL      = 0x05
TYPE_FUNCTION  = 0x06
```

### Instruction Encoding
```
Opcode: uint8
Operand1: uint16 (optional)
Operand2: uint16 (optional)
```

## Runtime Data Types

### Value Representation
```rust
enum Value {
    Integer(i64),
    Float(f64),
    String(String),
    Boolean(bool),
    Null,
    Array(Vec<Value>),
    Object(HashMap<String, Value>),
    Function(FunctionRef),
    Closure(ClosureRef),
}
```

### Function Frame
```rust
struct Frame {
    function: FunctionRef,
    locals: Vec<Value>,
    instruction_pointer: usize,
    stack_base: usize,
}
```

## Garbage Collection

### Mark and Sweep Algorithm
1. **Mark Phase**: Traverse from roots (stack, globals)
2. **Sweep Phase**: Deallocate unmarked objects
3. **Compact Phase**: Defragment heap (optional)

### GC Roots
- Operand stack values
- Local variables in call frames
- Global variables
- Constant pool references

## Compilation Pipeline

```
FlowLang Source
      ↓
   Lexer
      ↓
   Parser
      ↓
    AST
      ↓
 Semantic Analysis
      ↓
 Bytecode Generator
      ↓
  Optimizer
      ↓
 Bytecode Output
```

## Example Compilation

### FlowLang Source
```flow
def add with x, y do
    return x + y
end

let result be add(5, 3)
show result
```

### Generated Bytecode
```
# Function 'add'
LOAD_LOCAL 0        # Load x
LOAD_LOCAL 1        # Load y
ADD                 # x + y
RETURN_VALUE        # Return result

# Main execution
LOAD_CONST 0        # Load function 'add'
LOAD_CONST 1        # Load 5
LOAD_CONST 2        # Load 3
CALL 2              # Call add(5, 3)
STORE_GLOBAL "result" # Store result
LOAD_GLOBAL "result" # Load result
CALL_BUILTIN "show" # Call show function
```

## Performance Considerations

### Optimization Opportunities
- **Constant Folding**: Evaluate constants at compile time
- **Dead Code Elimination**: Remove unreachable code
- **Peephole Optimization**: Local instruction patterns
- **Register Allocation**: Minimize stack operations

### JIT Compilation Hooks
- Hot path detection counters
- Native code generation points
- Deoptimization support

## Implementation Phases

### Phase 1: Basic VM
- Core instruction set
- Stack management
- Simple garbage collection

### Phase 2: Advanced Features
- Object system
- Closures
- Exception handling

### Phase 3: Optimization
- JIT compilation
- Advanced GC
- Performance profiling

This specification provides the foundation for implementing a production-ready FlowLang virtual machine that can execute independently of Rust.